/*
 * Copyright (c) 2026 Layered Queue Driver
 * SPDX-License-Identifier: Apache-2.0
 *
 * Event and output driver system
 * 
 * Events are the pure output of the engine processing step.
 * Output drivers adapt these events to hardware (CAN, GPIO, etc.).
 */

#ifndef LQ_EVENT_H_
#define LQ_EVENT_H_

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Output type identifiers
 * 
 * Defines the target protocol/bus for output events.
 */
enum lq_output_type {
    LQ_OUTPUT_CAN,              /**< Standard CAN 2.0 */
    LQ_OUTPUT_J1939,            /**< SAE J1939 (CAN-based) */
    LQ_OUTPUT_CANOPEN,          /**< CANopen protocol */
    LQ_OUTPUT_GPIO,             /**< GPIO output */
    LQ_OUTPUT_UART,             /**< UART/Serial output */
    LQ_OUTPUT_SPI,              /**< SPI bus output */
    LQ_OUTPUT_I2C,              /**< I2C bus output */
    LQ_OUTPUT_PWM,              /**< PWM output */
    LQ_OUTPUT_DAC,              /**< DAC (analog output) */
    LQ_OUTPUT_MODBUS,           /**< Modbus RTU/TCP */
};

/**
 * @brief Event status codes
 */
enum lq_event_status {
    LQ_EVENT_OK = 0,              /**< Normal operation */
    LQ_EVENT_DEGRADED = 1,        /**< Degraded but functional */
    LQ_EVENT_OUT_OF_RANGE = 2,    /**< Out of acceptable range */
    LQ_EVENT_ERROR = 3,           /**< Hardware/communication error */
    LQ_EVENT_TIMEOUT = 4,         /**< Data timeout */
    LQ_EVENT_INCONSISTENT = 5,    /**< Redundant sources disagree */
};

/**
 * @brief Event generated by mid-level driver
 * 
 * Pure data structure representing a processed sensor value.
 * No RTOS dependencies - just data.
 */
struct lq_event {
    uint32_t source_id;           /**< Source driver ID */
    int32_t value;                /**< Processed value */
    enum lq_event_status status;  /**< Event status */
    uint64_t timestamp;           /**< Event timestamp (microseconds) */
};

/**
 * @brief Output event for hardware transmission
 * 
 * Generated by cyclic schedulers or on-change triggers.
 * Represents a value ready to be transmitted on a bus/interface.
 */
struct lq_output_event {
    enum lq_output_type type;     /**< Output protocol/bus type */
    uint32_t target_id;           /**< Protocol-specific ID (PGN, COB-ID, etc) */
    int32_t value;                /**< Value to transmit */
    uint32_t flags;               /**< Protocol-specific flags */
    uint64_t timestamp;           /**< Generation timestamp */
};

/* Forward declaration */
struct lq_output_driver;

/**
 * @brief Output driver virtual table
 * 
 * Defines interface for hardware output adapters.
 */
struct lq_output_vtbl {
    /**
     * @brief Initialize output hardware
     * 
     * @param out Output driver instance
     * @return 0 on success, negative errno on failure
     */
    int (*init)(struct lq_output_driver *out);
    
    /**
     * @brief Write event to hardware
     * 
     * Adapts the event to hardware-specific format and transmits.
     * 
     * @param out Output driver instance
     * @param event Event to output
     * @return 0 on success, negative errno on failure
     */
    int (*write)(struct lq_output_driver *out, const struct lq_event *event);
    
    /**
     * @brief Prepare for synchronized write (optional)
     * 
     * Called before a batch of synchronized writes.
     * Driver can buffer the event and wait for commit.
     * 
     * @param out Output driver instance
     * @param event Event to stage
     * @return 0 on success, negative errno on failure
     */
    int (*stage)(struct lq_output_driver *out, const struct lq_event *event);
    
    /**
     * @brief Commit staged writes (optional)
     * 
     * Called to atomically commit all staged writes.
     * 
     * @param out Output driver instance
     * @return 0 on success, negative errno on failure
     */
    int (*commit)(struct lq_output_driver *out);
};

/**
 * @brief Output driver instance
 */
struct lq_output_driver {
    const struct lq_output_vtbl *v;  /**< Virtual table */
    void *ctx;                        /**< Driver-specific context */
    const struct lq_mid_driver *src;  /**< Source mid-level driver */
    uint64_t period_us;               /**< Output period (0 = on-change) */
    uint64_t last_output_ts;          /**< Last output timestamp */
};

/**
 * @brief Initialize output driver
 * 
 * @param out Output driver instance
 * @return 0 on success, negative errno on failure
 */
static inline int lq_output_init(struct lq_output_driver *out)
{
    if (!out || !out->v || !out->v->init) {
        return -22; /* -EINVAL */
    }
    return out->v->init(out);
}

/**
 * @brief Write event to output
 * 
 * @param out Output driver instance
 * @param event Event to write
 * @return 0 on success, negative errno on failure
 */
static inline int lq_output_write(struct lq_output_driver *out, 
                                   const struct lq_event *event)
{
    if (!out || !out->v || !out->v->write) {
        return -22; /* -EINVAL */
    }
    return out->v->write(out, event);
}

/* ============================================================================
 * Common output driver types
 * ============================================================================ */

/**
 * @brief CAN output driver context
 */
struct lq_output_can_ctx {
    uint32_t pgn;                 /**< Parameter Group Number */
    uint8_t priority;             /**< CAN priority */
    void *can_dev;                /**< CAN device handle */
};

/**
 * @brief GPIO output driver context
 */
struct lq_output_gpio_ctx {
    uint32_t pin;                 /**< GPIO pin number */
    bool active_high;             /**< Pin polarity */
    void *gpio_dev;               /**< GPIO device handle */
};

/**
 * @brief Serial/UART output driver context
 */
struct lq_output_uart_ctx {
    void *uart_dev;               /**< UART device handle */
    uint32_t baud;                /**< Baud rate */
};

#ifdef __cplusplus
}
#endif

#endif /* LQ_EVENT_H_ */
